# 剑指Offer

* **剑指Offer题解**
   * 面试题3：[二维数组中的查找](#3-二维数组中的查找)
   * 面试题4：[替换空格](#4-替换空格)
   * 面试题5：[从尾到头打印链表](#5-从尾到头打印链表)
   * 面试题6：[重建二叉树](#6-重建二叉树)
   * 面试题7：[用两个栈实现队列](#7-用两个栈实现队列)
   * 面试题8：[旋转数组中最小数字](#8-旋转数组中最小数字)
   * 面试题9：[斐波那契数列](#9-斐波那契数列)
   * 面试题9-2：[跳台阶](#9-2-跳台阶)
   * 面试题9-3：[变态跳台阶](#9-3-变态跳台阶)
   * 面试题9-4：[矩形覆盖](#9-4-矩形覆盖)
   * 面试题10：[二进制中1的个数](#10-二进制中1的个数)
   * 面试题11：[数值的整数次方](#11-数值的整数次方)
   * 面试题12：[打印1到最大的n位数](#12-打印1到最大的n位数)
   * 面试题13：[在O_1时间删除链表结点](#13-在O_1时间删除链表结点)
   * 面试题14：[调整数组顺序使奇数位于偶数前面](#14-调整数组顺序使奇数位于偶数前面)
   * 面试题15：[链表中倒数第k个结点](#15-链表中倒数第k个结点)
   * 面试题16：[反转链表](#16-反转链表)
   * 面试题17：[合并两个排序的链表](#17-合并两个排序的链表)
   * 面试题18：[树的子结构](#18-树的子结构)
   * 面试题19：[二叉树的镜像](#19-二叉树的镜像)
   * 面试题20：[顺时针打印矩阵](#20-顺时针打印矩阵)
   * 面试题21：[包含min函数的栈](#21-包含min函数的栈)
   * 面试题22：[栈的压入、弹出序列](#22-栈的压入、弹出序列)
   * 面试题23：[从上往下打印二叉树](#23-从上往下打印二叉树)
   * 面试题24：[二叉搜索树的后续遍历序列](#24-二叉搜索树的后续遍历序列)
   * 面试题25：[二叉树中和为某一值的路径](#25-二叉树中和为某一值的路径)
   * 面试题26：[复杂链表的复制](#26-复杂链表的复制)
   * 面试题27：[二叉搜索树与双向链表](#27-二叉搜索树与双向链表)
   * 面试题28：[字符串的排列](#28-字符串的排列)
   * 面试题29：[数组中出现次数超过一半的数字](#29-数组中出现次数超过一半的数字)
   * 面试题30：[最小的K个数](#30-最小的K个数)
   * 面试题31：[连续子数组的最大和](#31-连续子数组的最大和)
   * 面试题32：[从1到n整数中1出现的次数](#32-从1到n整数中1出现的次数)
   * 面试题33：[把数组排成最小的数](#33-把数组排成最小的数)
   * 面试题34：[丑数](#34-丑数)
   * 面试题35：[第一个只出现一次的字符](#35-第一个只出现一次的字符)
   * 面试题36：[数组中的逆序对](#36-数组中的逆序对)
   * 面试题37：[两个链表的第一个公共结点](#37-两个链表的第一个公共结点)
   * 面试题38：[数字在排序数组中出现的次数](#38-数字在排序数组中出现的次数)
   * 面试题39：[二叉树的深度](#39-二叉树的深度)
   * 面试题39-2：[平衡二叉树](#39-2-平衡二叉树)
   * 面试题40：[数组中只出现一次的数字](#40-数组中只出现一次的数字)
   * 面试题41：[和为s的两个数字VS和为s的连续正数序列](#41-和为s的两个数字VS和为s的连续正数序列)
   * 面试题42：[翻转单词顺序VS左旋转字符串](#42-翻转单词顺序VS左旋转字符串)
   * 面试题43：[n个骰子的点数](#43-n个骰子的点数)
   * 面试题44：[扑克牌的顺子](#44-扑克牌的顺子)
   * 面试题45：[圆圈中最后剩下的数字](#45-圆圈中最后剩下的数字)
   * 面试题46：[求1+2+3+...+n](#46-求1+2+3+...+n)
   * 面试题47：[不用减加乘除做加法](#47-不用减加乘除做加法)
   * 面试题48：[不能被继承的类](#48-不能被继承的类)
   * 面试题49：[把字符串转换成整数](#49-把字符串转换成整数)
   * 面试题50：[树中两个结点的最低公共祖先](#50-树中两个结点的最低公共祖先)

   扩展：

   * 面试题：[左旋转字符串](#左旋转字符串)
   * 面试题：[二叉搜索树的第k个结点](#二叉搜索树的第k个结点)
   * 面试题：[TEMP](#TEMP)
   * 面试题：[TEMP](#TEMP)
   * 面试题：[正则表达式匹配](#正则表达式匹配)
   * 面试题：[表示数值的字符串](#表示数值的字符串)
   * 面试题：[链表中环的入口结点](#链表中环的入口结点)
   * 面试题：[删除链表中重复的结点](#删除链表中重复的结点)
   * 面试题：[二叉树的下一个结点](#二叉树的下一个结点)
   * 面试题：[对称的二叉树](#对称的二叉树)
   * 面试题：[按之字形顺序打印二叉树](#按之字形顺序打印二叉树)
   * 面试题：[把二叉树打印成多行](#把二叉树打印成多行)
   * 面试题：[数据流中的中位数](#数据流中的中位数)
   * 面试题：[滑动窗口的最大值](#滑动窗口的最大值)
   * 面试题：[矩阵中的路径](#矩阵中的路径)
   * 面试题：[机器人的运动范围](#机器人的运动范围)
   * 面试题：[剪绳子](#剪绳子)



## 3-二维数组中的查找

题目描述：
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
```python
链接：https://www.nowcoder.com/questionTerminal/abc3fe2ce8e146608e868a70efebf62e?f=discussion
来源：牛客网

class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        rows = len(array) - 1
        cols= len(array[0]) - 1
        i = rows
        j = 0
        while j<=cols and i>=0:
            if target<array[i][j]:
                i -= 1
            elif target>array[i][j]:
                j += 1
            else:
                return True
        return False
```

## 4-替换空格
题目描述：
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。
```python
class Solution:
    def replaceSpace(self, s):
        ans = []
        for i in s:
            if i == ' ':
                ans.append('%20')
            else:
                ans.append(i)
        return "".join(ans)
```


## 5-从尾到头打印链表
题目描述：
输入一个链表，按链表从尾到头的顺序返回一个ArrayList。
```python
链接：https://www.nowcoder.com/questionTerminal/d0267f7f55b3412ba93bd35cfa8e8035?f=discussion
来源：牛客网

class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        lst,lst_bak = [],[]
        if not listNode:
            return lst
        while listNode:
            lst.append(listNode.val)
            listNode = listNode.next
        while lst:
            lst_bak.append(lst.pop())
        return lst_bak
```


## 6-重建二叉树

题目描述：
输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。
```python
链接：https://www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6?f=discussion
来源：牛客网

class Solution:
    # 返回构造的TreeNode根节点
    def reConstructBinaryTree(self, pre, tin):
        # write code here
        if len(pre) == 0:
            return None
        elif len(pre) == 1:
            return TreeNode(pre[0])
        else:
            ans = TreeNode(pre[0])
            ans.left = self.reConstructBinaryTree(pre[1:tin.index(pre[0])+1], tin[:tin.index(pre[0])])
            ans.right = self.reConstructBinaryTree(pre[tin.index(pre[0])+1:], tin[tin.index(pre[0])+1:])
            return ans
```

## 7-用两个栈实现队列

题目描述：
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。
```python
链接：https://www.nowcoder.com/questionTerminal/54275ddae22f475981afa2244dd448c6?f=discussion
来源：牛客网

class Solution:
    def __init__(self):
        self.stackA = []
        self.stackB = []

    def push(self, node):
        # write code here
        self.stackA.append(node)

    def pop(self):
        # return xx
        if self.stackB:
            return self.stackB.pop()
        elif not self.stackA:
            return None
        else:
            while self.stackA:
                self.stackB.append(self.stackA.pop())
            return self.stackB.pop()
```

## 8-旋转数组中最小数字

题目描述：
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

```python
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        if len(rotateArray) == 1:
            return rotateArray[0]
        right = len(rotateArray) - 1
        left = 0

        while left < right:
            if right - left == 1:
                mid = right
                break
            mid = (left + right) // 2
            if rotateArray[mid] >= rotateArray[left]:
                left = mid
            elif rotateArray[mid] <= rotateArray[right]:
                right = mid
        return rotateArray[mid]
```

## 9-斐波那契数列

题目描述：
大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39

```python
class Solution:
    def Fibonacci(self, n):
        # write code here
        result = [0, 1]
        if n in result:
            return result[n]
        fibNMinusOne = 1
        fibNMinusTwo = 0
        for i in range(2, n+1):
            fibN = fibNMinusOne + fibNMinusTwo

            fibNMinusTwo = fibNMinusOne
            fibNMinusOne = fibN
        return fibN
```

## 9-跳台阶

题目描述：
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

```python
class Solution:
    def jumpFloor(self, number):
        res = [1, 2]
        if number in res:
            return number

        fibNMinusTwo = 1
        fibNMinusOne = 2
        for i in range(2, number):
            fibN = fibNMinusTwo + fibNMinusOne
            fibNMinusTwo = fibNMinusOne
            fibNMinusOne = fibN
        return fibN
```

## 9-2-变态跳台阶

题目描述
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

```python
class Solution:
    def jumpFloorII(self, number):
        return 2**(number-1)
```

## 9-3-矩形覆盖
题目描述：
我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

比如n=3时，2*3的矩形块有3种覆盖方法：

```python
class Solution:
    def rectCover(self, number):
        res = [0, 1, 2]
        if number in res:
            return number

        fibNMinusTwo = 1
        fibNMinusOne = 2
        for i in range(2, number):
            fibN = fibNMinusTwo + fibNMinusOne
            fibNMinusTwo = fibNMinusOne
            fibNMinusOne = fibN
        return fibN
```

## 10-二进制中1的个数
题目描述：
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。

```python
class Solution:
    def NumberOf1(self, n):
        count = 0
        if n < 0:
            n = n & 0xffffffff
        while n:
            count += 1
            n = (n - 1) & n
        return count
```

## 11-数值的整数次方
题目描述：
给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。

保证base和exponent不同时为0

```python
class Solution:
    def Power(self, base, exponent):
        abs_exponent = abs(exponent)
        ans = base
        for i in range(abs_exponent-1):
            ans *= base
        if exponent < 0:
            return 1/ans
        elif exponent == 0 and base != 0:
            return 1
        elif exponent == 0 and base == 0:
            return 0
        else:
            return ans
```

## 12-打印1到最大的n位数
题目描述：
输入数字n，按顺序打印出从1最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。

```python

```

## 13-在O_1时间删除链表结点
题目描述：
给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。

```python

```

## 14-调整数组顺序使奇数位于偶数前面

题目描述
输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

```python
class Solution:
    def reOrderArray(self, array):
        m = len(array)
        k = 0  # 记录已经摆好位置的奇数的个数
        for i in range(m):
            if array[i] % 2 == 1:
                j = i
                while j > k:
                    tmp = array[j]
                    array[j] = array[j-1]
                    array[j-1] = tmp
                    j -= 1
                k += 1
        return array
```

如果没有要求相对位置不变：

```python
class Solution:
    def reOrderArray(self, array):
        pBegin = 0
        pEnd = len(array) - 1
        while pBegin < pEnd:
            while pBegin < pEnd and array[pBegin] % 2 != 0:
                pBegin += 1
            while pBegin < pEnd and array[pEnd] % 2 != 1:
                pEnd -= 1
            if pBegin < pEnd:
                temp = array[pBegin]
                array[pBegin] = array[pEnd]
                array[pEnd] = temp
        return array
```
## 15-链表中倒数第k个结点

题目描述：
输入一个链表，输出该链表中倒数第k个结点。

```python
class Solution:
    def FindKthToTail(self, head, k):
        if head == None or k <= 0:
            return None
        p1 = head
        p2 = head
        for i in range(k):
            if p1:
                p1 = p1.next
            else:
                return None
        while p1:
            p1 = p1.next
            p2 = p2.next
        return p2
```

## 16-反转链表
题目描述：
输入一个链表，反转链表后，输出新链表的表头。
```python
链接：https://www.nowcoder.com/questionTerminal/75e878df47f24fdc9dc3e400ec6058ca?f=discussion
来源：牛客网

class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        if pHead==None or pHead.next==None:
            return pHead
        pre = None
        cur = pHead
        while cur!=None:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
```

## 17-合并两个排序的链表
题目描述
输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。


递归版
```python
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        if not pHead1:
            return pHead2
        if not pHead2:
            return pHead1
        if pHead1.val >= pHead2.val:
            pHead2.next = self.Merge(pHead2.next, pHead1)
            return pHead2
        if pHead1.val <= pHead2.val:
            pHead1.next = self.Merge(pHead1.next, pHead2)
            return pHead1
```

非递归版
```python
链接：https://www.nowcoder.com/questionTerminal/d8b6b4358f774294a89de2a6ac4d9337?f=discussion
来源：牛客网

if(list1 == null){
            return list2;
        }
        if(list2 == null){
            return list1;
        }
        ListNode mergeHead = null;
        ListNode current = null;     
        while(list1!=null && list2!=null){
            if(list1.val <= list2.val){
                if(mergeHead == null){
                   mergeHead = current = list1;
                }else{
                   current.next = list1;
                   current = current.next;
                }
                list1 = list1.next;
            }else{
                if(mergeHead == null){
                   mergeHead = current = list2;
                }else{
                   current.next = list2;
                   current = current.next;
                }
                list2 = list2.next;
            }
        }
        if(list1 == null){
            current.next = list2;
        }else{
            current.next = list1;
        }
        return mergeHead;

```

## 18-树的子结构

题目描述
输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）

```python
链接：https://www.nowcoder.com/questionTerminal/6e196c44c7004d15b1610b9afca8bd88?f=discussion
来源：牛客网

class Solution:
    def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        result = False
        if pRoot1 != None and pRoot2 != None:
            if pRoot1.val == pRoot2.val:
                result = self.DoesTree1haveTree2(pRoot1, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.left, pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.right, pRoot2)
        return result
    # 用于递归判断树的每个节点是否相同
    # 需要注意的地方是: 前两个if语句不可以颠倒顺序
    # 如果颠倒顺序, 会先判断pRoot1是否为None, 其实这个时候pRoot2的结点已经遍历完成确定相等了, 但是返回了False, 判断错误
    def DoesTree1haveTree2(self, pRoot1, pRoot2):
        if pRoot2 == None:
            return True
        if pRoot1 == None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        return self.DoesTree1haveTree2(pRoot1.left, pRoot2.left) and self.DoesTree1haveTree2(pRoot1.right, pRoot2.right)
```
```python
链接：https://www.nowcoder.com/questionTerminal/6e196c44c7004d15b1610b9afca8bd88?f=discussion
来源：牛客网

class Solution:
    def HasSubtree(self, pRoot1, pRoot2):

        def convert(p):
            if p:
                return str(p.val) +  convert(p.left) + convert(p.right)
            else:
                return ""
        return convert(pRoot2) in convert(pRoot1) if pRoot2 else False
```

## 19-二叉树的镜像

题目描述：
操作给定的二叉树，将其变换为源二叉树的镜像。
输入描述:
二叉树的镜像定义：源二叉树
```
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5
```

```python
class Solution:
    def Mirror(self, root):
        if not root:
            return None
        if root.left:
            root.left = self.Mirror(root.left)
        if root.right:
            root.right = self.Mirror(root.right)
        temp = root.left
        root.left = root.right
        root.right = temp
        return root
```

## 20-顺时针打印矩阵
题目描述：
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.

```python
class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        # write code here
        if not matrix:
            return []
        columns = len(matrix[0])
        rows = len(matrix)

        def printMatrixCircle(start):
            endRow = rows - 1 - start
            endColumn = columns - 1 - start

            # 从左到右打印一行
            for y in range(start, endColumn + 1):
                result.append(matrix[start][y])

            # 从上到下打印一列
            if endRow > start:
                for x in range(start + 1, endRow + 1):
                    result.append(matrix[x][endColumn])

            # 从右到左打印一行
            if endColumn > start and endRow > start:
                for y in range(endColumn - 1, start - 1, -1):
                    result.append(matrix[endRow][y])

            # 从下到上打印
            if endRow > start + 1 and endColumn > start:
                for x in range(endRow - 1, start, -1):
                    result.append(matrix[x][start])

        start = 0
        result = []
        while columns > start * 2 and rows > start * 2:
            printMatrixCircle(start)
            start += 1

        return result
```

## 21-包含min函数的栈
题目描述：
定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。
注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。

```python
链接：https://www.nowcoder.com/questionTerminal/4c776177d2c04c2494f2555c9fcc1e49?f=discussion
来源：牛客网

class Solution:
    def __init__(self):
        self.stack = []
        self.assist = []

    def push(self, node):
        min = self.min()
        if not min or node < min:
            self.assist.append(node)
        else:
            self.assist.append(min)
        self.stack.append(node)

    def pop(self):
        if self.stack:
            self.assist.pop()
            return self.stack.pop()

    def top(self):
        # write code here
        if self.stack:
            return self.stack[-1]

    def min(self):
        # write code here
        if self.assist:
            return self.assist[-1]
```

## 22-栈的压入、弹出序列
题目描述：
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

```python
链接：https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106?f=discussion
来源：牛客网

class Solution:
    def IsPopOrder(self, pushV, popV):
        # stack中存入pushV中取出的数据
        stack=[]
        while popV:
            # 如果第一个元素相等，直接都弹出，根本不用压入stack
            if pushV and popV[0]==pushV[0]:
                popV.pop(0)
                pushV.pop(0)
            #如果stack的最后一个元素与popV中第一个元素相等，将两个元素都弹出
            elif stack and stack[-1]==popV[0]:
                stack.pop()
                popV.pop(0)
            # 如果pushV中有数据，压入stack
            elif pushV:
                stack.append(pushV.pop(0))
            # 上面情况都不满足，直接返回false。
            else:
                return False
        return True
```

## 23-从上往下打印二叉树
题目描述
从上往下打印出二叉树的每个节点，同层节点从左至右打印。

```python
class Solution:
    # 返回从上到下每个节点值列表，例：[1,2,3]
    def PrintFromTopToBottom(self, root):
        if not root:
            return []
        result = []
        stack = [root]
        while stack:
            node = stack.pop(0)
            result.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        return result
```

## 24-二叉搜索树的后续遍历序列

题目描述
输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。
```python
链接：https://www.nowcoder.com/questionTerminal/a861533d45854474ac791d90e447bafd?f=discussion
来源：牛客网

class Solution:
    def VerifySquenceOfBST(self, sequence):
        # write code here
        if not sequence:
            return False

        return self.helper(sequence)

    # 增加helper函数是因为对于递归来说sequence为空可以作为终止条件，而对于判断BST而言 sequence为空是False
    def helper(self, sequence):
        if not sequence:
            return True

        root = sequence[-1]
        for i in range(len(sequence)):
            if sequence[i] > root:
                break

        for right in sequence[i:-1]:
            if right < root:
                return False

        return self.helper(sequence[:i]) and self.helper(sequence[i:-1])
```

链接：https://www.nowcoder.com/questionTerminal/a861533d45854474ac791d90e447bafd?f=discussion
来源：牛客网

python:后序遍历 的序列中，最后一个数字是树的根节点 ，数组中前面的数字可以分为两部分：第一部分是左子树节点 的值，都比根节点的值小；第二部分 是右子树 节点的值，都比 根 节点 的值大，后面用递归分别判断前后两部分 是否 符合以上原则

```python
链接：https://www.nowcoder.com/questionTerminal/a861533d45854474ac791d90e447bafd?f=discussion
来源：牛客网

class Solution:
    def VerifySquenceOfBST(self, sequence):
        # write code here
        if sequence==None or len(sequence)==0:
            return False
        length=len(sequence)
        root=sequence[length-1]
        # 在二叉搜索 树中 左子树节点小于根节点
        for i in range(length):
            if sequence[i]>root:
                break
        # 二叉搜索树中右子树的节点都大于根节点
        for j  in range(i,length):
            if sequence[j]<root:
                return False
        # 判断左子树是否为二叉树
        left=True
        if  i>0:
            left=self.VerifySquenceOfBST(sequence[0:i])
        # 判断 右子树是否为二叉树
        right=True
        if i<length-1:
            right=self.VerifySquenceOfBST(sequence[i:-1])
        return left and right
```

## 25-二叉树中和为某一值的路径
题目描述：
输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)

思路：
- 递归先序遍历树， 把结点加入路径。
- 若该结点是叶子结点则比较当前路径和是否等于期待和。
- 弹出结点，每一轮递归返回到父结点时，当前路径也应该回退一个结点

```python
链接：https://www.nowcoder.com/questionTerminal/b736e784e3e34731af99065031301bca?f=discussion
来源：牛客网

class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        # write code here
        if not root:
            return []

        result = []

        def FindPathMain(root, path, currentSum):
            currentSum += root.val

            path.append(root)
            isLeaf = root.left == None and root.right == None

            if currentSum == expectNumber and isLeaf:
                onePath = []
                for node in path:
                    onePath.append(node.val)
                result.append(onePath)

            if currentSum < expectNumber:
                if root.left:
                    FindPathMain(root.left, path, currentSum)
                if root.right:
                    FindPathMain(root.right, path, currentSum)

            path.pop()

        FindPathMain(root, [], 0)

        return result
```

## 26-复杂链表的复制
题目描述
输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

```python
链接：https://www.nowcoder.com/questionTerminal/f836b2c43afc4b35ad6adc41ec941dba?f=discussion
来源：牛客网

class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):
        if not pHead:
            return None

        dummy = pHead

        # first step, N' to N next
        while dummy:
            dummynext = dummy.next
            copynode = RandomListNode(dummy.label)
            copynode.next = dummynext
            dummy.next = copynode
            dummy = dummynext

        dummy = pHead

        # second step, random' to random'
        while dummy:
            dummyrandom = dummy.random
            copynode = dummy.next
            if dummyrandom:
                copynode.random = dummyrandom.next
            dummy = copynode.next

        # third step, split linked list
        dummy = pHead
        copyHead = pHead.next
        while dummy:
            copyNode = dummy.next
            dummynext = copyNode.next
            dummy.next = dummynext
            if dummynext:
                copyNode.next = dummynext.next
            else:
                copyNode.next = None
            dummy = dummynext

        return copyHead
```

## 27-二叉搜索树与双向链表

题目描述：
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

非递归版本
```python
链接：https://www.nowcoder.com/questionTerminal/947f6eb80d944a84850b0538bf0ec3a5?f=discussion
来源：牛客网

class Solution:
    def Convert(self, pRootOfTree):
        if not pRootOfTree:
            return None

        p = pRootOfTree

        stack = []
        resStack = []

        while p or stack:
            if p:
                stack.append(p)
                p = p.left
            else:
                node = stack.pop()
                resStack.append(node)
                p = node.right

        resP = resStack[0]
        while resStack:
            top = resStack.pop(0)
            if resStack:
                top.right = resStack[0]
                resStack[0].left = top

        return resP
```

递归版本
```python
链接：https://www.nowcoder.com/questionTerminal/947f6eb80d944a84850b0538bf0ec3a5?f=discussion
来源：牛客网

class Solution:
    def Convert(self, root):
        if not root:
            return None
        if not root.left and not root.right:
            return root

        # 将左子树构建成双链表，返回链表头
        left = self.Convert(root.left)
        p = left

        # 定位至左子树的最右的一个结点
        while left and p.right:
            p = p.right

        # 如果左子树不为空，将当前root加到左子树链表
        if left:
            p.right = root
            root.left = p

        # 将右子树构造成双链表，返回链表头
        right = self.Convert(root.right)
        # 如果右子树不为空，将该链表追加到root结点之后
        if right:
            right.left = root
            root.right = right

        return left if left else root
```

## 28-字符串的排列

题目描述：
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

输入描述:
输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。


```python
链接：https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7?f=discussion
来源：牛客网

class Solution:
    def Permutation(self, ss):
        if len(ss) <= 1:
            return ss
        res = set()
        # 遍历字符串，固定第一个元素，第一个元素可以取a,b,c...，然后递归求解
        for i in range(len(ss)):
            for j in self.Permutation(ss[:i] + ss[i+1:]): # 依次固定了元素，其他的全排列（递归求解）
                res.add(ss[i] + j) # 集合添加元素的方法add(),集合添加去重（若存在重复字符，排列后会存在相同，如baa,baa）
        return sorted(res)         # sorted()能对可迭代对象进行排序,结果返回一个新的list
```

## 29-数组中出现次数超过一半的数字
题目描述：
数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。

```python
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        length = len(numbers)
        counts = {}
        for n in numbers:
            if n not in counts.keys():
                counts[n] = 0
            counts[n] += 1
            if counts[n] > length // 2:
                return n
        return 0
```

```python
class Solution:
    def CheckMoreThanHalf(self, array, number):
        times = 0
        length = len(array)
        for i in range(length):
            if array[i] == number:
                times += 1
        isMoreThanHalf = True
        if times * 2 <= length:
            g_bInputInvlid = True
            isMoreThanHalf = False
        return isMoreThanHalf

    def MoreThanHalfNum(self, array):
        result = array[0]
        times = 1
        length = len(array)
        for i in range(1, length):
            if times == 0:
                result = array[i]
                times = 1
            elif array[i] == result:
                times += 1
            else:
                times -= 1

        if not self.CheckMoreThanHalf(array, result):
            return 0
```

## 30-最小的K个数

题目描述：
输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。

```python
import random
class Solution:
    def GetLeastNumbers_Solution(self, tinput, k):
        n = len(tinput)
        if n <=0 or k > n or k == 0:
            return []
        start = 0
        end = n - 1
        index = self.partition(tinput,start,end)
        while index != k-1:
            if index > k - 1:
                end = index - 1
                index = self.partition(tinput, start, end)
            else:
                start = index + 1
                index = self.partition(tinput, start, end)
        res = tinput[:k]
        res = sorted(res)
        return res

    def partition(self, arr, start, end):
        if start == end:
            p = start
        else:
            p = random.randrange(start, end)
        small = start - 1
        arr[p], arr[end] = arr[end], arr[p]
        for index in range(start, end):
            if arr[index] < arr[end]:
                small += 1
                if small != index:
                    arr[small], arr[index] = arr[index], arr[small]
        small += 1
        arr[small], arr[end] = arr[end], arr[small]
        return small
```

## 31-连续子数组的最大和
题目描述：
HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)

```python
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        n = len(array)
        if n == 0:
            return 0
        sum = array[0]; tempsum = array[0]
        for i in range(1, n):
            if tempsum >= 0:
                tempsum = tempsum + array[i]
            else:
                tempsum = array[i]
            if tempsum > sum:
                sum = tempsum
        return sum
```

## 32-从1到n整数中1出现的次数
题目描述：
求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。

```python
class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        counts = 0
        for i in range(n+1):
            num = str(i)
            counts += num.count("1")
        return counts
```

## 33-把数组排成最小的数

题目描述：
输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。

```python
链接：https://www.nowcoder.com/questionTerminal/8fecd3f8ba334add803bf2a06af1b993?f=discussion
来源：牛客网

class Solution:
    def PrintMinNumber(self, numbers):
        # write code here
        if not numbers: return ""
        numbers = list(map(str, numbers))
        numbers.sort(cmp=lambda x, y: cmp(x + y, y + x))
        return "".join(numbers).lstrip('0') or'0'
```

```python
链接：https://www.nowcoder.com/questionTerminal/8fecd3f8ba334add803bf2a06af1b993?f=discussion
来源：牛客网

class Solution:
    def compare(self,num1,num2):
        t = str(num1)+str(num2)
        s = str(num2)+str(num1)
        if t>s:
            return 1
        elif t<s:
            return -1
        else:
            return 0

    def PrintMinNumber(self, numbers):
        # write code here
        if numbers is None:
            return ""
        lens = len(numbers)
        if lens ==0 :
            return ""
        tmpNumbers = sorted(numbers,cmp=self.compare)
        return int(''.join(str(x)for x in tmpNumbers))

print Solution().PrintMinNumber([3,32,321])
```

## 34-丑数

题目描述：
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

链接：https://www.nowcoder.com/questionTerminal/6aa9e04fc3794f68acf8778237ba065b?f=discussion
来源：牛客网

1.为什么分三个队列？
丑数数组里的数一定是有序的，因为我们是从丑数数组里的数乘以2,3,5选出的最小数，一定比以前未乘以2,3,5大，同时对于三个队列内部，按先后顺序乘以2,3,5分别放入，所以同一个队列内部也是有序的；

2.为什么比较三个队列头部最小的数放入丑数数组？
因为三个队列是有序的，所以取出三个头中最小的，等同于找到了三个队列所有数中最小的。

```python
class Solution:
    def GetUglyNumber_Solution(self, index):
        if index < 7:
            return index
        p2 = 0
        p3 = 0
        p5 = 0
        newNum = 1
        array = []
        array.append(newNum)

        while len(array) < index:
            newNum = min(array[p2] * 2, min(array[p3] * 3, array[p5] * 5))
            if array[p2] * 2 == newNum:
                p2 += 1
            if array[p3] * 3 == newNum:
                p3 += 1
            if array[p5] * 5 == newNum:
                p5 += 1
            array.append(newNum)
        return newNum
```

## 35-第一个只出现一次的字符
题目描述：
在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.

```python
import collections
class Solution:
    def FirstNotRepeatingChar(self, s):
        rec = collections.OrderedDict()
        for s_i in s:
            if s_i not in rec.keys():
                rec[s_i] = 1
            else:
                rec[s_i] += 1
        for key in rec.keys():
            if rec[key] == 1:
                return s.index(key)
        return -1
```

## 36-数组中的逆序对
题目描述：
在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007
输入描述:
题目保证输入的数组中没有的相同的数字

数据范围：

	对于%50的数据,size<=10^4

	对于%75的数据,size<=10^5

	对于%100的数据,size<=2*10^5

示例1
输入
```
1,2,3,4,5,6,7,0
```
输出
```
7
```

```python
class Solution:
    def InversePairs(self, data):
        count = 0
        copy = []
        for i in data:
            copy.append(i)
        copy.sort()

        for i in range(len(copy)):
            count += data.index(copy[i])
            data.remove(copy[i])
        return count%1000000007
```

## 37-两个链表的第一个公共结点
题目描述
输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）
```python
链接：https://www.nowcoder.com/questionTerminal/6ab1d9a29e88450685099d45c9e31e46?f=discussion
来源：牛客网

class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        p1,p2=pHead1,pHead2
        while p1!=p2:
            p1 = p1.next if p1 else pHead2
            p2 = p2.next if p2 else pHead1
        return p1
```

## 38-数字在排序数组中出现的次数

题目描述：
统计一个数字在排序数组中出现的次数。

```python
class Solution:
    def GetFirstK(self, data, k):
        low = 0
        high = len(data) - 1
        while low <= high:
            mid = (low + high) // 2
            if data[mid] < k:
                low = mid + 1
            elif data[mid] > k:
                high = mid - 1
            else:
                if mid == low or data[mid - 1] != k: #当到list[0]或不为k的时候跳出函数
                    return mid
                else:
                    high = mid - 1
        return -1

    def GetLastK(self, data, k):
        low = 0
        high = len(data) - 1
        while low <= high:
            mid = (low + high) // 2
            if data[mid] > k:
                high = mid - 1
            elif data[mid] < k:
                low = mid + 1
            else:
                if mid == high or data[mid + 1] != k:
                    return mid
                else:
                    low = mid + 1
        return -1

    def GetNumberOfK(self, data, k):
        if not data:
            return 0
        if self.GetLastK(data, k) == -1 and self.GetFirstK(data, k) == -1:
            return 0
        return self.GetLastK(data, k) - self.GetFirstK(data, k) + 1
```

## 39-二叉树的深度

题目描述：
输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

```python
class Solution:
    def TreeDepth(self, pRoot):
        if pRoot == None:
            return 0
        nLeft = self.TreeDepth(pRoot.left)
        nRight = self.TreeDepth(pRoot.right)
        return (nLeft + 1) if nLeft > nRight else (nRight + 1)
```

## 39-2-平衡二叉树

题目描述：
输入一棵二叉树，判断该二叉树是否是平衡二叉树。

```python
class Solution:
    def TreeDepth(self, pRoot):
        if pRoot == None:
            return 0
        nLeft = self.TreeDepth(pRoot.left)
        nRight = self.TreeDepth(pRoot.right)

        return (nLeft + 1) if nLeft > nRight else (nRight + 1)

    def IsBalanced_Solution(self, pRoot):
        if pRoot == None:
            return True
        nLeft = self.TreeDepth(pRoot.left)
        nRight = self.TreeDepth(pRoot.right)
        diff = nLeft - nRight
        if abs(diff) > 1:
            return False
        return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)
```

## 40-数组中只出现一次的数字

题目描述：
一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
```python
链接：https://www.nowcoder.com/questionTerminal/e02fdb54d7524710a7d664d082bb7811?f=discussion
来源：牛客网


# hashMap法
class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        hashMap = {}
        for i in array:
            if str(i) in hashMap:
                hashMap[str(i)] += 1
            else:
                hashMap[str(i)] = 1
        res = []
        for k in hashMap.keys():
            if hashMap[k] == 1:
                res.append(int(k))
        return res

# 异或法
class Solution:
    def FindNumsAppearOnce(self, array):
        if not array:
            return []
        # 对array中的数字进行异或运算
        tmp = 0
        for i in array:
            tmp ^= i
        # 获取tmp中最低位1的位置
        idx = 0
        while (tmp & 1) == 0:
            tmp >>= 1
            idx += 1
        a = b = 0
        for i in array:
            if self.isBit(i, idx):
                a ^= i
            else:
                b ^= i
        return [a, b]

    def isBit(self, num, idx):
        """
        判断num的二进制从低到高idx位是不是1
        :param num: 数字
        :param idx: 二进制从低到高位置
        :return: num的idx位是否为1
        """
        num = num >> idx
        return num & 1
```

## 左旋转字符串
题目描述：
汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

```python
class Solution:
    def LeftRotateString(self, s, n):
        if len(s) == 0 or n <= 0:
            return s
        def Inver(s, start, end):
            while end > start:
                s[start], s[end] = s[end], s[start]
                end -= 1
                start += 1
            return s
        s = list(s)
        s = Inver(s, 0, len(s)-1)
        s = Inver(s, 0, len(s)-1-n)
        s = Inver(s, len(s)-n, len(s)-1)
        return "".join(s)
```

## 构建乘积数组

题目描述：
给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0] * A[1] * ... * A[i-1] * A[i+1] * ... * A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）

![构建乘积数组-1](https://uploadfiles.nowcoder.com/images/20160829/841505_1472459965615_8640A8F86FB2AB3117629E2456D8C652)


```python
链接：https://www.nowcoder.com/questionTerminal/94a4d381a68b47b7a8bed86f2975db46?f=discussion
来源：牛客网

public class Solution {
    public int[] multiply(int[] A) {
        int length = A.length;
        int[] B = new int[length];
        if(length != 0 ){
            B[0] = 1;
            //计算下三角连乘
            for(int i = 1; i < length; i++){
                B[i] = B[i-1] * A[i-1];
            }
            int temp = 1;
            //计算上三角
            for(int j = length-2; j >= 0; j--){
                temp *= A[j+1];
                B[j] *= temp;
            }
        }
        return B;
    }
}
```

## 正则表达式匹配
题目描述：
请实现一个函数用来匹配包括'.'和'\*'的正则表达式。模式中的字符'.'表示任意一个字符，而'\*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

```python
链接：https://www.nowcoder.com/questionTerminal/45327ae22b7b413ea21df13ee7d6429c?f=discussion
来源：牛客网

class Solution:
    # s, pattern都是字符串
    def match(self, s, pattern):
        # 如果s与pattern都为空，则True
        if len(s) == 0 and len(pattern) == 0:
            return True
        # 如果s不为空，而pattern为空，则False
        elif len(s) != 0 and len(pattern) == 0:
            return False
        # 如果s为空，而pattern不为空，则需要判断
        elif len(s) == 0 and len(pattern) != 0:
            # pattern中的第二个字符为*，则pattern后移两位继续比较
            if len(pattern) > 1 and pattern[1] == '*':
                return self.match(s, pattern[2:])
            else:
                return False
        # s与pattern都不为空的情况
        else:
            # pattern的第二个字符为*的情况
            if len(pattern) > 1 and pattern[1] == '*':
                # s与pattern的第一个元素不同，则s不变，pattern后移两位，相当于pattern前两位当成空
                if s[0] != pattern[0] and pattern[0] != '.':
                    return self.match(s, pattern[2:])
                else:
                    # 如果s[0]与pattern[0]相同，且pattern[1]为*，这个时候有三种情况
                    # pattern后移2个，s不变；相当于把pattern前两位当成空，匹配后面的
                    # pattern后移2个，s后移1个；相当于pattern前两位与s[0]匹配
                    # pattern不变，s后移1个；相当于pattern前两位，与s中的多位进行匹配，因为*可以匹配多位
                    return self.match(s, pattern[2:]) or self.match(s[1:], pattern[2:]) or self.match(s[1:], pattern)
            # pattern第二个字符不为*的情况
            else:
                if s[0] == pattern[0] or pattern[0] == '.':
                    return self.match(s[1:], pattern[1:])
                else:
                    return False
```

## 表示数值的字符串

题目描述：
请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100","5e2","-123","3.1416"和"-1E-16"都表示数值。 但是"12e","1a3.14","1.2.3","+-5"和"12e+4.3"都不是。

```python
链接：https://www.nowcoder.com/questionTerminal/6f8c901d091949a5837e24bb82a731f2?f=discussion
来源：牛客网

class Solution:
    # s字符串
    def isNumeric(self, s):
        # write code here
        if len(s) <= 0:
            return False
        # 分别标记是否出现过正负号、小数点、e，因为这几个需要特殊考虑
        has_sign = False
        has_point = False
        has_e = False
        for i in range(len(s)):
            # 对于e的情况
            if s[i] == 'E' or s[i] == 'e':
                # 不同出现两个e
                if has_e:
                    return False
                # e不能出现在最后面，因为e后面要接数字
                else:
                    has_e = True
                    if i == len(s) -1:
                        return False   
            # 对于符号位的情况
            elif s[i] == '+' or s[i] == '-':
                # 如果前面已经出现过了符号位，那么这个符号位，必须是跟在e后面的
                if has_sign:
                    if s[i-1] != 'e' and s[i-1] != 'E':
                        return False
                # 如果这是第一次出现符号位，而且出现的位置不是字符串第一个位置，那么就只能出现在e后面
                else:
                    has_sign = True
                    if i > 0 and s[i-1] != 'e' and s[i-1] != 'E':
                        return False
            # 对于小数点的情况
            elif s[i] == '.':
                # 小数点不能出现两次；而且如果已经出现过e了，那么就不能再出现小数点，因为e后面只能是整数
                if has_point or has_e:
                    return False
                # 如果是第一次出现小数点，如果前面出现过e，那么还是不能出现小数点
                else:
                    has_point = True
                    if i > 0 and (s[i-1] == 'e' or s[i-1] == 'E'):
                        return False
            else:
                # 其他字符必须是‘0’到‘9’之间的
                if s[i] < '0' or s[i] > '9':
                    return False
        return True
```

## 链表中环的入口结点
题目描述：
给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。

快指针路程=a+(b+c)k+b ，k>=1  其中b+c为环的长度，k为绕环的圈数（k>=1,即最少一圈，不能是0圈，不然和慢指针走的一样长，矛盾）。

慢指针路程=a+b

快指针走的路程是慢指针的两倍，所以：
（a+b）\*2=a+(b+c)k+b

化简可得：
a=(k-1)(b+c)+c 这个式子的意思是： 链表头到环入口的距离=相遇点到环入口的距离+（k-1）圈环长度。其中k>=1,所以k-1>=0圈。所以两个指针分别从链表头和相遇点出发，最后一定相遇于环入口。

```python
class Solution:
    def EntryNodeOfLoop(self, pHead):
        fast = pHead
        low = pHead

        while fast != None and fast.next != None:
            fast = fast.next.next
            low = low.next
            if fast == low:
                break
        if fast == None or fast.next == None:
            return None
        low = pHead
        while fast != low:
            fast = fast.next
            low = low.next
        return low
```


## 删除链表中重复的结点

题目描述
在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5

```python
链接：https://www.nowcoder.com/questionTerminal/fc533c45b73a41b0b44ccba763f866ef?f=discussion
来源：牛客网

class Solution:
    def deleteDuplication(self, pHead):
        # write code here
        if pHead == None or pHead.next == None:
            return pHead
        new_head = ListNode(-1)
        new_head.next = pHead
        pre = new_head
        p = pHead
        nex = None
        while p != None and p.next != None:
            nex = p.next
            if p.val == nex.val:
                while nex != None and nex.val == p.val:
                    nex = nex.next
                pre.next = nex
                p = nex
            else:
                pre = p
                p = p.next
        return new_head.next
```

## 二叉树的下一个结点

题目描述：
给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。


![二叉树的下一个结点](https://uploadfiles.nowcoder.com/files/20171225/773262_1514198075109_20151104234034251)

链接：https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e?f=discussion
来源：牛客网

结合图，我们可发现分成两大类：1、有右子树的，那么下个结点就是右子树最左边的点；（eg：D，B，E，A，C，G） 2、没有右子树的，也可以分成两类，a)是父节点左孩子（eg：N，I，L） ，那么父节点就是下一个节点 ； b)是父节点的右孩子（eg：H，J，K，M）找他的父节点的父节点的父节点...直到当前结点是其父节点的左孩子位置。如果没有eg：M，那么他就是尾节点。

```python
链接：https://www.nowcoder.com/questionTerminal/9023a0c988684a53960365b889ceaf5e?f=discussion
来源：牛客网

class Solution:
    def GetNext(self, pNode):
        if pNode.right:#有右子树
            p=pNode.right
            while p.left:
                p=p.left
            return p
        while pNode.next:#无右子树，则找第一个当前节点是父节点左孩子的节点
            if(pNode.next.left==pNode):
                return pNode.next
            pNode = pNode.next#沿着父节点向上遍历
        return None  #到了根节点仍没找到，则返回空
```


## 对称的二叉树

题目描述：
请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。

思路：
* 首先根节点以及其左右子树，左子树的左子树和右子树的右子树相同
* 左子树的右子树和右子树的左子树相同即可，采用递归

```python
class Solution:
    def comRoot(self, left, right):
        if left == None:
            return right == None
        if right == None:
            return left == None
        if left.val != right.val:
            return False
        return self.comRoot(left.right, right.left) and self.comRoot(left.left, right.right)

    def isSymmetrical(self, pRoot):
        if pRoot == None:
            return True
        return self.comRoot(pRoot.left, pRoot.right)
```

## 按之字形顺序打印二叉树

题目描述：
请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。


```python
链接：https://www.nowcoder.com/questionTerminal/91b69814117f4e8097390d107d2efbe0?f=discussion
来源：牛客网

class Solution:
    def Print(self, pRoot):
        if not pRoot:
            return []

        stack = [pRoot]
        result = []
        while stack:
            res = []
            nextStack = []
            for i in stack:
                res.append(i.val)
                if i.left:
                    nextStack.append(i.left)
                if i.right:
                    nextStack.append(i.right)
            stack=nextStack
            result.append(res)
        returnResult = []
        for i, v in enumerate(result):
            if i % 2 == 0:
                returnResult.append(v)
            else:
                returnResult.append(v[::-1])  # 奇数层则反向打印，从0层开始
        return returnResult
```

## 把二叉树打印成多行

题目描述：
从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。
```python
class Solution:
    # 返回二维列表[[1,2],[4,5]]
    def Print(self, pRoot):
        if not pRoot:
            return []

        stack = [pRoot]
        result = []
        while stack:
            res = []
            nextStack = []
            for node in stack:
                res.append(node.val)
                if node.left:
                    nextStack.append(node.left)
                if node.right:
                    nextStack.append(node.right)
            stack = nextStack
            result.append(res)
        return result
```

## 序列化二叉树

题目描述：
请实现两个函数，分别用来序列化和反序列化二叉树

二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。

二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。


```python
链接：https://www.nowcoder.com/questionTerminal/cf7e25aa97c04cc1a68c8f040e71fb84?f=discussion
来源：牛客网

class Solution:
    def __init__(self):
        self.flag = -1

    def Serialize(self, root):
        # write code here
        if not root:
            return '#,'
        return str(root.val)+','+self.Serialize(root.left)+self.Serialize(root.right)

    def Deserialize(self, s):
        # write code here
        self.flag += 1
        l = s.split(',')

        if self.flag >= len(s):
            return None
        root = None

        if l[self.flag] != '#':
            root = TreeNode(int(l[self.flag]))
            root.left = self.Deserialize(s)
            root.right = self.Deserialize(s)
        return root
```

## 二叉搜索树的第k个结点

题目描述：
给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。

思路：二叉搜索树按照中序遍历的顺序打印出来正好就是排序好的顺序。所以，按照中序遍历顺序找到第k个结点就是结果。

```python
class Solution:
    # 返回对应节点TreeNode
    def __init__(self):
        self.index = 0
    def KthNode(self, pRoot, k):
        if pRoot == None:
            return None
        node = self.KthNode(pRoot.left, k)
        if node != None:
            return node
        self.index += 1
        if self.index == k:
            return pRoot
        node = self.KthNode(pRoot.right, k)
        if node != None:
            return node
```

## 数据流中的中位数
题目描述：
如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

```python

```

## 滑动窗口的最大值

题目描述：
给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

**解题**：双向队列，queue存入num的位置，时间复杂度O(n)
```python
class Solution:
    def maxInWindows(self, num, size):
        queue, res, i = [], [], 0
        if size <= 0:
            return res
        for i in range(len(num)):
            # 若最大值queue[0]位置过期 则弹出
            if len(queue) > 0 and i-size+1 > queue[0]:   
                queue.pop(0)
            # 每次弹出所有比num[i]小的数字
            while len(queue) > 0 and num[queue[-1]] < num[i]:  
                queue.pop()
            queue.append(i)
            if i >= size-1:
                res.append(num[queue[0]])
        return res
```

## 矩阵中的路径

题目描述：
请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如
$$
  \begin{matrix}
   a & b & c & e \\
   s & f & c & s \\
   a & d & e & e
  \end{matrix} \tag{1}
$$
矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。


**题解：**
链接：https://www.nowcoder.com/questionTerminal/c61c6999eecb4b8f88a98f66b273a3cc?f=discussion
来源：牛客网

回溯
基本思想：

0. 根据给定数组，初始化一个标志位数组，初始化为false，表示未走过，true表示已经走过，不能走第二次
1. 根据行数和列数，遍历数组，先找到一个与str字符串的第一个元素相匹配的矩阵元素，进入judge
2. 根据i和j先确定一维数组的位置，因为给定的matrix是一个一维数组
3. 确定递归终止条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的，这三类情况，都直接false，说明这条路不通
4. 若k，就是待判定的字符串str的索引已经判断到了最后一位，此时说明是匹配成功的
5. 下面就是本题的精髓，递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。
6. 走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。

```python
class Solution:
    def hasPath(self, matrix, rows, cols, path):
        flag = [False for _ in range(len(matrix))]
        for i in range(rows):
            for j in range(cols):
                if self.judge(matrix, i, j, rows, cols, flag, path, 0):
                    return True
        return False

    def judge(self, matrix, i, j, rows, cols, flag, path, k):
        index = i * cols + j
        if i<0 or j<0 or i>=rows or j>=cols or matrix[index]!=path[k] or flag[index]==True:
            return False
        if k == len(path)-1:
            return True
        flag[index] = True
        if self.judge(matrix,i-1,j,rows,cols,flag,path,k+1) or \
            self.judge(matrix,i+1,j,rows,cols,flag,path,k+1) or \
            self.judge(matrix,i,j-1,rows,cols,flag,path,k+1) or \
            self.judge(matrix,i,j+1,rows,cols,flag,path,k+1):
            return True
        flag[index] = False
        return False

print(Solution().hasPath(matrix="ABCESFCSADEE",
                         rows=3,
                         cols=4,
                         path="ABCCED"))
```

## 机器人的运动范围
题目描述：
地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？

题解：

思路：将地图全部置1，遍历能够到达的点，将遍历的点置0并令计数+1.这个思路在找前后左右相连的点很有用，比如leetcode中的海岛个数问题/最大海岛问题都可以用这种方法来求解。


```python
class Solution:
    def __init__(self):
        self.count = 0

    def movingCount(self, threshold, rows, cols):
        arr = [[1 for i in range(cols)] for j in range(rows)]
        self.findway(arr, 0, 0, threshold)
        return self.count

    def findway(self, arr, i, j, k):
        if i < 0 or j < 0 or i >= len(arr) or j >= len(arr[0]):
            return
        tmpi = list(map(int, list(str(i))))
        tmpj = list(map(int, list(str(j))))
        if sum(tmpi) + sum(tmpj) > k or arr[i][j] != 1:
            return
        arr[i][j] = 0
        self.count += 1
        self.findway(arr, i + 1, j, k)
        self.findway(arr, i - 1, j, k)
        self.findway(arr, i, j + 1, k)
        self.findway(arr, i, j - 1, k)

print(Solution().movingCount(12, 10, 8))
```

## 剪绳子
题目描述：
给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
输入描述:
输入一个数n，意义见题面。（2 <= n <= 60）
输出描述:
输出答案。

示例1
```
输入 8

输出 18
```

```python
class Solution:
    def cutRope(self, number):
        if number == 2:
            return 1
        if number == 3:
            return 2
        x = number % 3
        y = number // 3
        if x == 0:
            return 3 ** y
        elif x == 1:
            return 2 * 2 * 3 ** (y-1)
        else:
            return 2 * 3 ** y
```
